
declare module "sideflux" {

// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../utilitaire
//   ../sideflux
//   ../react
//   ../immutable

    import { OnlyReadable } from "utilitaire";
    import * as React from "react";
    import { HasDescriptor, JsObject } from "utilitaire";
    import { Map, Set } from "immutable";
    import { Future, Option } from "utilitaire";
    import { HasId, Partial, Copyable, Mergeable, Splittable } from "utilitaire";


    export type ActionType = {
        readonly [key: string]: string;
    };
    export type ActionReturnType<T> = {
        [U in keyof T]: (...any: any[]) => Action;
    };
    export class Action {
        readonly name: string;
        readonly params: any[];
        constructor(name: string, ..._params: any[]);
        static from<T extends ActionType>(actionTypes: T, descriptor: ActionReturnType<T>): ActionReturnType<T> & {
            Types: Readonly<T>;
        };
        static readonly onDataChanged: (data: any) => Action;
    }

    export const GenericActionType: {
        tryToInitialize: string;
        initializedWithSuccess: string;
        failedToInitialize: string;
    };
    export class GenericActionImpl {
        tryToInitialize(value?: any): Action;
        initializedWithSuccess<T>(value: T): Action;
        failedToInitialize<T>(value: T): Action;
    }
    export const GenericAction: GenericActionImpl;

    export abstract class PureContainerComponent<T, U extends HasDescriptor<U>> extends React.PureComponent<T, JsObject> {
        protected store: Store<U>;
        protected constructor(props: T, store: Store<U>);
        readonly currentState: U;
        componentWillUnmount(): void;
        onStateUpdated(): void;
    }
    export abstract class ContainerComponent<T, U extends HasDescriptor<U>> extends React.Component<T, JsObject> {
        protected store: Store<U>;
        protected constructor(props: T, store: Store<U>);
        readonly currentState: U;
        componentWillUnmount(): void;
        onStateUpdated(): void;
    }

    export class Dispatcher {
        dispatchTable: Map<string, Set<Store<any>>>;
        register(store: Store<any>): this;
        dispatch(action: Action): void;
    }
    export const GlobalDispatcher: Dispatcher;

    export abstract class State<T, U> {
        constructor(desc: T);
        abstract getInitialState(): T;
    }

    export type StoreDesc<T, U> = {
        initialState: T;
        initialStateFn?: () => T;
        updatedBy?: Array<Store<any>>;
        dependsOn?: Array<Store<any>>;
        onDataCacheEvent?: (dataCacheEvent: DataCacheEvent) => void;
        withStoreContext?: {
            [P in keyof U]: (context: StoreContext<T>, ...any: any[]) => T;
        };
        withCurrentState?: {
            [P in keyof U]: (currentState: T, ...any: any[]) => T;
        };
        onDataChanged?: (data: any) => void;
    };
    export type ManagedComponent = ContainerComponent<any, any> | PureContainerComponent<any, any>;
    export class Store<T extends HasDescriptor<T>> {
        readonly initialState: T;
        readonly handledActionsTypes: Array<string>;
        readonly descriptor: StoreDesc<T, any>;
        readonly cache: StoreCache;
        readonly currentState: T;
        protected managedComponents: Set<ManagedComponent>;
        static create<T extends HasDescriptor<T>, U>(actionsTypes: U, descriptor: StoreDesc<T, U>): Store<T>;
        register(component: ManagedComponent): this;
        unregister(component: ManagedComponent): this;
        notifyComponents(): void;
        watchFuture<T>(future: Future<T>): Future<T>;
        onDataChanged(data: any): void;
        onUpdate(fn: (oldState: T, newState: T) => void): void;
        dispatch(action: Action): void;
        handleAction(action: Action): void;
    }
    export type StoreContextDesc<T> = {
        currentState: T;
    };
    export class StoreContext<T> {
        protected desc: StoreContextDesc<T>;
        protected functions: Array<() => void>;
        constructor(desc: StoreContextDesc<T>);
        readonly currentState: T;
        onAllComponentsUpdated(fn: () => void): StoreContext<T>;
    }
    export class StoreCache {
        protected store: Store<any>;
        constructor(store: Store<any>);
        getData<U extends CachableData<any>>(by: {
            dataId: string;
        }): U;
        getDataFuture<U extends CachableData<any>>(by: {
            dataId: string;
            ifDataMiss: () => Future<U>;
        }): Future<U>;
        getDataOption<U extends CachableData<any>>(by: {
            dataId: string;
        }): Option<U>;
    }

    export class DataCacheImpl {
        protected _state: DataState;
        constructor(_state: DataState);
        registerForDataChanges(param: {
            dataId: string;
            notifyWhenDataChanges?: Store<any>;
        }): this;
        add(data: CachableData<any>): this;
        addAll(array: Array<CachableData<any>>): this;
        getData<T extends CachableData<any>>(param: {
            dataId: string;
            notifyWhenDataChanges?: Store<any>;
        }): T;
        getDataFuture<T extends CachableData<any>>(param: {
            dataId: string;
            notifyWhenDataChanges?: Store<any>;
            ifDataMiss: () => Future<T>;
        }): Future<T>;
        getDataOption<T extends CachableData<any>>(param: {
            dataId: string;
            notifyWhenDataChanges?: Store<any>;
        }): Option<T>;
    }
    export const DataCache: DataCacheImpl;

    export abstract class DataCacheEvent {
        protected _data: any;
        constructor(_data: any);
        readonly name: string;
        isCreated(): boolean;
        isUpdated(): boolean;
        isDeleted(): boolean;
        ifIsCreated<T>(fn: (data: T) => any): DataCacheEvent;
        ifIsCreatedOrUpdated<T>(fn: (data: T) => any): DataCacheEvent;
        ifIsUpdated<T>(fn: (data: T) => any): DataCacheEvent;
        ifIsDeleted<T>(fn: (data: T) => any): DataCacheEvent;
        ifIsCreatedAndMatch<T>(predicate: (data: T) => boolean, fn: (data: T) => any): DataCacheEvent;
        ifIsUpdatedAndMatch<T>(predicate: (data: T) => boolean, fn: (data: T) => any): DataCacheEvent;
        ifIsDeletedAndMatch<T>(predicate: (data: T) => boolean, fn: (data: T) => any): DataCacheEvent;
    }

    export type CachableData<T> = HasId<T> & Mergeable<T, any> & Splittable<T, any>;
    export type DataStateDescriptor = {
        dataMap: Map<string, CachableData<any>>;
    };
    export class DataState implements Copyable<DataState, Partial<DataStateDescriptor>> {
        constructor(desc: DataStateDescriptor);
        static _initialState: DataState;
        static getInitialState(): DataState;
        readonly dataMap: Map<string, CachableData<any>>;
        copy(newState: Partial<DataStateDescriptor>): DataState;
    }
}

