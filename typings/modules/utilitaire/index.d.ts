declare module "utilitaire" {

// Generated by dts-bundle v0.6.1
// Dependencies for this module:
//   ../es6-promise

    import {Promise} from "es6-promise";

    export abstract class Option<T> {
        protected _value: T;
        readonly value: T;

        valueOrElse(value: T): T;

        valueOrNull(): T;

        isDefined(): boolean;

        isEmpty(): boolean;

        flatMap<U>(fn: (T) => Option<U>): Option<U>;

        map<U>(fn: (T) => U): Option<U>;

        filter(fn: (T) => boolean): Option<T>;

        filterNot(fn: (T) => boolean): Option<T>;

        select(fn: (T) => boolean): Option<T>;

        reject(fn: (T) => boolean): Option<T>;

        exists(fn: (T) => boolean): boolean;

        forEach(fn: (T) => void): void;

        static isDefinedValue(value: any): boolean;

        static of<T>(value: T): Option<T>;

        static empty<T>(): Option<T>;
    }
    export class Some<T> extends Option<T> {
        constructor(_value: T);
    }
    export const None: Option<any>;

    export type VoidFunction = () => void;
    export type OnComplete<Result> = {
        ifSuccess?: (result: Result) => void;
        ifFailure?: (exception: Exception) => void;
        whatEver?: () => void;
    };
    export class Future<Result> {
        protected _promise: Promise<Result>;
        protected _tryOption: any;

        protected constructor(_promise: Promise<Result>, _tryOption: any);

        static fromPromise<Result>(promise: Promise<Result>): Future<Result>;

        static of<Result>(fn: () => Result): Future<Result>;

        static executeAfter<Result>(timeout: number, fn: () => Result): Future<Result>;

        static neverCompleted<Result>(): Future<Result>;

        static fromTry<Result>(t: Try<Result>): Future<Result>;

        static successful<Result>(value: Result): Future<Result>;

        static failed<Result>(exception: Exception): Future<Result>;

        static notYetStarted<Result>(): Future<Result>;

        isCompleted(): any;

        valueOrNull(): Result;

        exceptionOrNull(): Exception;

        isPending(): boolean;

        isSuccess(): any;

        isFailure(): any;

        map<U>(fn: (result: Result) => U): Future<U>;

        filter(fn: (res: Result) => boolean): Future<Result>;

        filterNot(fn: (res: Result) => boolean): Future<Result>;

        select(fn: (res: Result) => boolean): Future<Result>;

        reject(fn: (res: Result) => boolean): Future<Result>;

        flatMap<U>(fn: (result: Result) => Future<U>): Future<U>;

        toTryOption(): Option<Try<Result>>;

        toPromise(): Promise<Result>;

        toArray(): Array<Result>;

        forEach(fn: (res: Result) => void): void;

        onSuccess(fn: (res: Result) => void): Future<Result>;

        onFailure(fn: (exception: Exception) => void): Future<Result>;

        onComplete(fn: VoidFunction | {
            ifSuccess: (result: Result) => void;
            ifFailure: (exception: Exception) => void;
        }): Future<Result>;

        fold<U>(fold: {
            ifPending: () => U;
            ifNotYetStarted: () => U;
            ifSuccess: (result: Result) => U;
            ifFailure: (exception: Exception) => U;
        } | {
            otherwise: () => U;
            ifPending?: () => U;
            ifNotYetStarted?: () => U;
            ifSuccess?: (result: Result) => U;
            ifFailure?: (exception: Exception) => U;
        }): U;

        recover<U>(fn: (exception: Exception) => U): Future<U>;

        recoverWith<U>(fn: (exception: Exception) => Future<U>): Future<U>;

        transform<U>(transformer: {
            ifSuccess: (result: Result) => U;
            ifFailure: (exception: Exception) => U;
        }): Future<U>;

        transformWith<U>(transformer: {
            ifSuccess: (result: Result) => Future<U>;
            ifFailure: (exception: Exception) => Future<U>;
        }): Future<U>;
    }

    export abstract class Try<Result> {
        protected _value: Result;
        protected _exception: Exception;

        protected static safeApply<Result>(fn: () => Result): Try<Result>;

        protected static safeApplyTry<Result>(fn: () => Try<Result>): Try<Result>;

        static of<Result>(fn: () => Result): Try<Result>;

        static failed<Result>(exception: Exception): Try<Result>;

        static successful<Result>(value: Result): Try<Result>;

        isSuccess(): boolean;

        isFailure(): boolean;

        valueOrElse(other: Result): Result;

        valueOrNull(): Result;

        value(): Result;

        exception(): Exception;

        exceptionOrElse(other: Exception): Exception;

        exceptionOrNull(): Exception;

        toOption(): Option<Result>;

        toFuture(): Future<Result>;

        forEach(fn: (Result) => void): void;

        map<U>(fn: (T) => U): Try<U>;

        select(fn: (T) => boolean): Try<Result>;

        filter(fn: (T) => boolean): Try<Result>;

        recover(fn: (Exception) => Result): Try<Result>;

        recoverWith(fn: (Exception) => Try<Result>): Try<Result>;

        flatMap<U>(fn: (T) => Try<U>): Try<U>;

        transform<U>(trans: {
            ifSuccess: (T) => Try<U>;
            ifFailure: (exception: Exception) => Try<U>;
        }): Try<U>;

        fold<U>(fold: {
            ifSuccess: (T) => U;
            ifFailure: (exception: Exception) => U;
        }): U;
    }

    export function onlyReadable<T extends JsObject>(obj: T): OnlyReadable<T>;

    export function unsafeCast<A, B>(instance: A): B;

    export type Partial<T> = {
        [P in keyof T]?: T[P];
        };
    export type OnlyReadable<T> = {
        readonly [P in keyof T]: T[P];
        };
    export interface HasId<T> {
        id: string;
    }
    export interface HasDescriptor<T> {
        readonly desc : JsObject
    }
    export interface Splittable<T, U> {
        split(): Array<U>;
    }
    export interface Mergeable<T, U> {
        merge(other: Array<U>): T;
    }
    export interface UpdatableInPlace<T, U> {
        updateInPlace(desc: U): T;
    }
    export interface Copyable<T, U> {
        copy(desc: Partial<U>): T;
    }
    export type JsObject = {
        [propName: string]: any;
    };
    export type Union2<T1, T2> = T1 | T2;
    export type Function1<T1, R> = (T1) => R;
    export class RemoteObject<T, RemoteDesc extends JsObject, LocalDesc extends JsObject> {
        protected readonly desc: LocalDesc;

        constructor(descOrFunction: Union2<LocalDesc, (RemoteDesc) => LocalDesc>, remote?: RemoteDesc);

        protected cloneDesc(): LocalDesc;
    }
    export type Otherwise<T> = {
        otherwise: T;
    };
    export type OtherwisePartial<T, U> = Partial<U> & Otherwise<T>;
    export type OtherwiseUnion<Otherwise, U> = U | OtherwisePartial<Otherwise, U>;
    export function hasNotOtherwise<T, U>(fold: OtherwiseUnion<() => T, U>): fold is U;

    export type ExceptionDesc = {
        message: string;
    };
    export class Exception {
        protected message: string;

        constructor(message: string);

        static createFrom(e: any): Exception;
    }
    export type DefaultExceptionDesc = {
        message?: string;
        cause: any;
    };
    export class GenericException extends Exception {
        protected desc: DefaultExceptionDesc;

        constructor(desc: DefaultExceptionDesc);

        readonly cause: any;
    }
    export class NoSuchElementException extends Exception {
        protected desc: ExceptionDesc;

        constructor(desc: ExceptionDesc);

        readonly message: any;
    }
    export class FutureNotYetStartedException extends Exception {
        constructor();
    }

}